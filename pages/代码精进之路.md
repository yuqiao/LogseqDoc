---
annotation-target: assets/代码精进之路_1641218044952_0.pdf
---
type:: book
tags:: book
author:: 张建飞
status:: reading
topic:: computor
score:: 7
summary::

- 电子书
	- ![代码精进之路.pdf](../assets/代码精进之路_1641218044952_0.pdf)
- 代码精进之路
	- ## 前言 
	  collapsed:: true
	  一边是无止境的业务需求，一边是补丁加补丁的业务代码，开发人 员被夹在中间，像一只困兽，向左走，还是向右走?方向在哪里?我倍 感困惑。就像Robert C. Martin说的:“不管你们有多敬业，加多少班， 在面对烂系统时，你仍然会寸步难行，因为你大部分的精力不是在应对 开发需求，而是在应对混乱。”
		- 软件复杂性的主要因素有哪些 #card
		  card-last-interval:: 4
		  card-repeats:: 1
		  card-ease-factor:: 2.36
		  card-next-schedule:: 2022-01-07T13:51:16.864Z
		  card-last-reviewed:: 2022-01-03T13:51:16.864Z
		  card-last-score:: 3
			- 软件的本质复杂性。问题域用其复杂性，而软件做实现过程中又又很大的灵活性和抽象性，导致软件具有天热的复杂性。
			- 缺少技艺。『写代码』作为一种技能，入门并不难，但要像高手那样优雅『写好代码』不是一件容易的事，需要持续学习和实践。
			- 糟糕的技术氛围。
			- 教条和妥协。在不恰当的场景使用了不恰当的解决方案，造成不必要的复杂性。我们向自己妥协，向产品经理妥协，向工期妥协，向技术债妥协，总有很多借口把设计糟糕，混乱丑陋的代码发布上线。
		- 一个程序员的『美德』是什么？ #card
		  card-last-interval:: 4
		  card-repeats:: 1
		  card-ease-factor:: 2.6
		  card-next-schedule:: 2022-01-07T13:51:48.113Z
		  card-last-reviewed:: 2022-01-03T13:51:48.113Z
		  card-last-score:: 5
			- 就在于他是否为后人留下一段看得懂，可维护性好的代码。
		- 如何获取写好代码的技艺？
			- 不是一蹴而就的，是一个系统化工程。
				- 思维习惯
				- 学习方法
	- ## 第1章 命名
	  collapsed:: true
	  好的命名可以极大地提升代码的可读性和可理解性。
		- ### 1.1　命名的力量 #card
		  card-last-interval:: 4
		  card-repeats:: 1
		  card-ease-factor:: 2.6
		  card-next-schedule:: 2022-01-07T14:00:01.475Z
		  card-last-reviewed:: 2022-01-03T14:00:01.475Z
		  card-last-score:: 5
		  collapsed:: true
			- ((61d30079-efd4-4132-a9ad-8f321b10335d))
			- 例子：
				- Alibaba
				- POJO (Plain Old Java Object)
		- ### 1.2　命名其实很难
		  collapsed:: true
		  命名的过程本身是一个抽象和思考的过程。
		  若我们不能找到一个合适的名字，往往说明我们对问题的理解还不够透彻。
		  一个好名字需要把要义浓缩到一到两个词中。
			- ((61d300c3-d0c4-48e2-8e27-9b8670ec68da))
		- ### 1.3　有意义的命名
		  collapsed:: true
			- 变量名如何命名？ #card
				- 应该是名词，正确描述业务。
				  ``` java
				  // 命名不好的
				  int d; //表示过去的天数
				  - // 命名好的
				  int elapsedTimeInDays;
				  ```
			- 函数名如何命名？ #card
				- 函数命名要具体。
				- 不推荐：
					- processData()
				- 推荐：
					- validateUserCredentials();
					- eliminateDuplicateRequests();
				- 函数命名要体现做什么， 而不是怎么做。
			- 类名如何命名？
				- 类是一组数据和操作的封装。 分为两大类：
					- 实体类， 承载核心业务数据和核心业务逻辑，命名要充分提现业务语义，并在团队内达成共识，例如：
						- Custormer
						- Bank
						- Employee
					- 辅助类, 辅佐实体类一起完成业务逻辑的，其命名要能够通过后缀来体现功能。
						- 例如：
							- 用来为Customer做控制路由的控制类CustomerController
							- 提供Customer服务的服务类CustomerService
						- 不建议用Helper、Util之类的后缀，因为其含义太过笼统，容易破坏SRP（单一职责原则）
							- 对于处理CSV，你可能这样写：
							  ```java
							  CSVHelper.parse(String);
							  CSVHelper.create(int[]);
							  ```
							- 更建议这样写：
							  ```java
							  CSVParser.parse(String) ;
							  CSVBuilder.create(int[]);
							  ```
		- ### 1.4 保持一致性
		  collapsed:: true
		  保持命名的一致性，可以提高代码的可读性，从而简化复杂度。
			- 方法名的约定。
				- | CRUD操作 | 方法名约定 | 
				  |  - |  - |
				  | 新增 |  create|
				  | 添加 | add |
				  | 删除 | remove |
				  | 修改 | update |
				  | 查询(单个结果) | get |
				  | 查询(多个结果) | list | 
				  | 分页查询 | page | 
				  | 统计 |  count |
			- 使用对仗词
				- add/remove
				- increment/decrement
				- open/close
				- insert/delete
				- show/hide
				- create/destroy
				- lock/unlock
				- source/target
				- first/last
				- min/max
				- start/stop
				- get/set
				- next/previous
				- up/down
				- old/new
			- 后置限定词,  放在名字的最坏。
				- Total/Count
				- Sum
				- Average
				- Max
				- Min
				- Id --> 序号
			- 统一业务语言
				- 确保团队在内部的所有交流、模型、代码和文档中都要使用同一种编程语言。 DDD中的重要概念。
			- 统一技术语言
				- DO
				- DAO
				- DTO
				- ServiceI
				- ServiceImpl
				- Component
				- Repository
				-
		- ### 1.5 自明的代码
		  ((61e3f3ff-ab09-4259-aa9c-218a7bba85e0))
			- 善用中间变量，把隐藏的计算过程以显性化的方式表达出来。
			- 使用设计模式语言。例如：
				- Spring里面的ApplicationListener  ---> 观察者模式，每一个被注册的ApplicationListener在Application状态发生变化时，都会接收到一个notify.
				- FilterChain ---> 责任链模式
			- 小心注释。
				- 不要复述功能
				- 要解释背后意图
		- ### 1.6 命名工具
			- 当你不知道如何优雅地给变量命名时，可以使用命名工具，快速搜索大型项目中的变量命名，看其他大型项目源码是如何命名的，哪些变量名的使用频率高。
			- OnlineSearch的插件
	- ## 第2章 规范
	  所谓信息熵，就是一条信息的信 息量大小和它的不确定性之间的关系。
	  事物的复杂程度在很大程度上取决于其有序程度，减少无序能在一定程度上降低复杂度，这正是规范的价值所在。通过规范，把无序的混沌控制在一个能够理解的范围内，从而帮助我们减少认知成本，降低对事物认知的复杂度。
		- ### 2.1　认知成本
		  collapsed:: true
			- 所谓认知，是指人们获得知识或应用知识的过程。
			- 知识是人类对经验范围内的感觉进行总结归纳之后发现的规律。混乱无序的东西没有规律，不能形成知识，也就不能被认知到，这就是有组织和无组织的复杂性的区别。
		- ### 2.2　混乱的代价
		  collapsed:: true
			- 认知是有成本的，而混乱的代价在于让我们对事物无法形成有效的记忆和认知，导致我们每次面对的问题都是新问题，每次面临的场景都是新场景，又要重新理解一遍。
			- 系统凌乱的代价：虽然知需要改一行代码，却需要找很久。 
			  系统无序 ---> 系统缺少代码组织结构规范。
			- 混乱是有代价的，我们有必要使用规范和约定来使大脑从记忆不同的代码段的随意性、偶然性差异中解脱出来。将我们有限的精力用在刀刃上，而不是用来疲于应对各种不一致和随心所欲的混乱。
		- ### 2.3　代码规范
			- #### 2.3.1　代码格式
				- 一个团队最好是选定一种格式，因为一致性可以减少复杂度。
			- #### 2.3.2　空行规范
				- ((61e42bf1-98de-47ed-be19-e51cf971e988))
			- ### 2.3.3　命名规范
				- Java命名约定：
					- 类名采用”大驼峰“形式。
					- 方法名采用”小驼峰“形式
					- 常量命名的字母全部大写，单词间用下划线连接。
					- 枚举以Enum或Type结尾，枚举类名称需全大写，单词间用下划线连接。
					- 抽象类名使用Abstract开头；异常类使用Exception结尾；实现类以impl结尾；测试类以它要测试的类名开始，以Test结尾。
					- 包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词，包名统一使用单数形式。通常以com或org开头，加上公司名，再加上组件或者功能模块名。
			- ### 2.3.4　日志规范
				- 要特别注意日志输出级别：
					- ERROR
						- 表示不能自己恢复的错误，需要立即被关注和解决。
							- 数据库操作错误
							- I/O错误
							- 未知的系统错误
						- 对于ERROR，我们不仅要打印线程堆栈，最好打印出一定的上下文（链路TraceId、用户Id、订单Id、外部传来的关键数据），以便于排查问题。
						- ERROR要接入监控和报警系统。ERROR需要人工介入处理，及时止损，否则会影响系统的可用性。
					- WARN
						- 对于可预知的业务问题，最好不要用ERROR输出日志，以免污染报警系统。
							- 参数校验不通过
							- 没有访问权限
						- 在短时间内产生过多的WARN日志，也是一种系统不健康的表现。因此，我们有必要为WARN配置一个适当阈值的报警。
					- INFO
						- 用于记录系统的基本运行过程和运行状态。
						- 优先根据INFO日志可初步定位，主要包括系统状态变化日志、业务流程的核心处理、关键动作和业务流程的状态变化。
					- DEBUG
						- DEBUG是输出调试信息，如request/response的对象内容。在输出对象内容时，要覆盖Object的toString方法。
						- 采用分布式配置工具来实现基于requestId判断的日志过滤。
			- ### 2.3.5　异常规范
				- #### 1. 异常处理
					- 需要统一的异常处理规范，避免增加人为的复杂性：
						- 代码中充斥着异常捕获的try/catch代码，搞乱了代码结构，将错误处理和正常流程混为一谈，严重影响代码的可读性。
						- 异常处理不统一，有的场景对外直接抛出异常，有的场景对外返回错误码。
					- 业务系统设定两个异常，分别是：
						- 业务异常BizException
						- 系统异常SysException
					- 不建议用Checked Exception, why? #card
						- 破坏了开闭原则。在软件中修改较低层级时，都将波及较高层级，修改好的模块必须重新构建、发布
					- ((61e430d4-6b82-431a-a723-de388e926631))
					- ((61e430fc-ddb8-4b48-a533-e7cdcc901d39))
				- #### 2. 错误码
					- ((61f75a88-26bd-44d3-826a-0ef99fc6fad2))
					- 两种方式：
						- 1. 编号错误码。比如Oracle.
						- 2. 显性性错误码
							- 可以将错误码对应为3部分： 类型+场景+自定义标识
							- 类型：
								- P: 参数异常
								- B: 业务异常
								- S: 系统异常
		- ### 2.4　埋点规范
			- ((61f75b95-a948-4070-88d1-6765758ac17b))
			-
		- ### 2.5　架构规范
		- ### 2.6　防止破窗
			- ((61f760ec-c37e-4fa8-9338-c993d2f510f1))
			-
		- ### 2.7　本章小结
			- ((61f761d1-cbf7-4d5a-9d9b-7459a495f63b))
	- ## 第3章 函数
	- ### 3.1　什么是函数
		- 函数指一个量随着另一个量的变化和变化。
	- ### 3.2　软件中的函数
	- ### 3.3　封装判断
	- ### 3.4　函数参数
	- ### 3.5　短小的函数
	- ### 3.6　职责单一
	- ### 3.7　精简辅助代码
	- ### 3.7.1　优化判空
	- ### 3.7.2　优化缓存判断
	- ### 3.7.3　优雅降级
	- ### 3.8　组合函数模式
	- ### 3.9　SLAP
		- ((61f8e1e3-4294-4f96-8606-810a9d1bd18c))
		-
	- ### 3.10　函数式编程
	- ### 3.11　本章小结
	- ## 第4章 设计原则
	- ### 4.1　SOLID概览
		- Single Responsibility Principle（SRP）：单一职责原则。
		- Open Close Principle（OCP）：开闭原则。
			- 可扩展性是我们衡量软件质量的一个重要指标。
		- Liskov Substitution Principle（LSP）：里氏替换原则。
			- 子类应该可以替换任何基类能够出现的地方。
			  id:: 620116f7-488d-4955-bca5-e59db31cc41c
		- Interface Segregation Principle（ISP）：接口隔离原则。
		- Dependency Inversion Principle（DIP）：依赖倒置原则。
	- ### 4.2　SRP
	- ### 4.3　OCP
	- ### 4.4　LSP
	- ### 4.4.1　警惕instanceof
	- ### 4.4.2　子类覆盖父类函数
	- ### 4.5　ISP
	- ### 4.6　DIP
	- ### 4.7　DRY
	- ### 4.8　YAGNI
	- ### 4.9　RuleofThree
	- ### 4.10　KISS原则
	- ### 4.11　POLA原则
	- ### 4.12　本章小结
	- ## 第5章　设计模式
		- ((6203cdbb-22dd-4170-a133-9fe2c7201a13))
		-
	- ### 5.1　模式
	- ### 5.2　GoF
	- ### 5.3　拦截器模式
		- ((6203ce9c-bc1b-4d0e-9229-c87f9c0c5633))
		-
	- ### 5.4　插件模式
		- ((62086301-9751-45c3-8521-db96a7e6150e))
		- 推荐开源项目： JPF (Java Plugin-in Framework)
	- ### 5.5　管道模式
		- 分治思想： 将功能分解放在多个管道里实现
	- ### 5.5.1　链式管道
		- 管道模式，涉及3个角色：
			- 阀门： 处理数据的节点
			- 管道： 组织各个阀门
			- 客户端： 构建管道并调用
		- 实现： 一般使用一个单向链表数据结构来
			- 阀门接口
			  ```java
			  public interface Valve {
			    Valve getNext();
			    void setNext(Valve v);
			    void invoke();
			  }
			  ```
			- 管道接口
			  ```java
			  public interface Pipeline {
			    Valve getHead();
			    Valve getTail();
			    void setTail(Valve v);
			    void addValve(Valve v)
			  }
			  ```
			- 阀门的基础实现
			  ```java
			  public abstract class ValveBase implements Valve{
			    
			  }
			  ```
			- 具体的阀门
			- 具体的管道
			- 组装管道
	- ### 5.5.2　流处理
	- ### 5.6　本章小结
	- ## 第6章　模型
	- ### 6.1　什么是模型
	- ### 6.1.1　物理模型
	- ### 6.1.2　数学模型
	- ### 6.1.3　概念模型
	- ### 6.1.4　思维模型
	- ### 6.1.5　模型不能代替现实
	- ### 6.2　UML
	- ### 6.3　类图
	- ### 6.3.1　类的UML表示法
	- ### 6.3.2　类的关联关系
	- ### 6.3.3　类的依赖关系
	- ### 6.3.4　类的泛化关系
	- ### 6.3.5　接口与实现关系
	- ### 6.4　领域模型
	- ### 6.5　敏捷建模
	- ### 6.6　广义模型
	- ### 6.6.1　C4模型
	- ### 6.6.2　UI流程图
	- ### 6.6.3　业务模型
	- ### 6.7　本章小结
	- ## 第7章　DDD的精髓
	- ### 7.1　什么是DDD
	- ### 7.2　初步体验DDD
	- ### 7.3　数据驱动和领域驱动
	- ### 7.3.1　数据驱动
	- ### 7.3.2　领域驱动
	- ### 7.3.3　ORM
	- ### 7.4　DDD的优势
	- ### 7.4.1　统一语言
	- ### 7.4.2　面向对象
	- ### 7.4.3　业务语义显性化
	- ### 7.4.4　分离业务逻辑和技术细节
	- ### 7.5　DDD的核心概念
	- ### 7.5.1　领域实体
	- ### 7.5.2　聚合根
	- ### 7.5.3　领域服务
	- ### 7.5.4　领域事件
	- ### 7.5.5　边界上下文
	- ### 7.6　领域建模方法
	- ### 7.6.1　用例分析法
	- ### 7.6.2　四色建模法
	- ### 7.7　模型演化
	- ### 7.8　为什么DDD饱受争议
	- ### 7.8.1　照搬概念
	- ### 7.8.2　抽象的灵活性
	- ### 7.8.3　领域层的边界
	- ### 7.9　本章小结
	- ## 第二部分 思想
	- ## 第8章 抽象
	- ### 8.1　伟大的抽象
	- ### 8.2　到底什么是抽象
	- ### 8.3　抽象是OO的基础
	- ### 8.4　抽象的层次性
	- ### 8.5　如何进行抽象
	- ### 8.5.1　寻找共性
	- ### 8.5.2　提升抽象层次
	- ### 8.5.3　构筑金字塔
	- ### 8.6　如何提升抽象思维
	- ### 8.6.1　多阅读
	- ### 8.6.2　多总结
	- ### 8.6.3　领域建模训练
	- ### 8.7　本章小结
	- ## 第9章 分治
	- ### 9.1　分治算法
	- ### 9.1.1　归并排序
	- ### 9.1.2　二分搜索
	- ### 9.1.3　K选择问题
	- ### 9.2　函数分解
	- ### 9.3　写代码的两次创造
	- ### 9.3.1　## 第一遍实现功能
	- ### 9.3.2　## 第二遍重构优化
	- ### 9.4　分治模式
	- ### 9.5　分层设计
	- ### 9.5.1　分层网络模型
	- ### 9.5.2　分层架构
	- ### 9.6　横切和竖切
	- ### 9.7　本章小结
	- ## 第10章 技术人的素养
	- ### 10.1　不教条
	- ### 10.1.1　瀑布还是敏捷
	- ### 10.1.2　贫血还是充血
	- ### 10.1.3　单体还是分布式
	- ### 10.2　批判性思维
	- ### 10.3　成长型思维
	- ### 10.4　结构化思维
	- ### 10.4.1　如何落地新团队
	- ### 10.4.2　如何做晋升述职
	- ### 10.5　工具化思维
	- ### 10.6　好奇心
	- ### 10.7　记笔记
	- ### 10.8　有目标
	- ### 10.9　选择的自由
	- ### 10.10　平和的心态
	- ### 10.11　精进
	- ### 10.12　本章小结
	- ## 第11章 技术Leader的修养
	- ### 11.1　技术氛围
	- ### 11.1.1　代码好坏味道
	- ### 11.1.2　技术分享
	- ### 11.1.3　CR周报
	- ### 11.1.4　读书会
	- ### 11.2　目标管理
	- ### 11.2.1　什么是OKR
	- ### 11.2.2　SMART原则
	- ### 11.2.3　OKR设定
	- ### 11.3　技术规划
	- ### 11.3.1　当前问题
	- ### 11.3.2　技术领域
	- ### 11.3.3　业务领域
	- ### 11.3.4　团队特色
	- ### 11.4　推理阶梯
	- ### 11.5　Leader和Manager的区别
	- ### 11.6　视人为人
	- ### 11.7　本章小结
	- ## 第三部分　实践
	- ## 第12章COLA架构
	- ### 12.1　软件架构
	- ### 12.2　典型的应用架构
	- ### 12.2.1　分层架构
	- ### 12.2.2　CQRS
	- ### 12.2.3　六边形架构
	- ### 12.2.4　洋葱架构
	- ### 12.2.5　DDD
	- ### 12.3　COLA架构设计
	- ### 12.3.1　分层设计
	- ### 12.3.2　扩展设计
	- ### 12.3.3　规范设计
	- ### 12.3.4　COLAArchetype
	- ### 12.4　COLA测试
	- ### 12.4.1　单元测试
	- ### 12.4.2　集成测试
	- ### 12.4.3　ColaMock
	- ### 12.5　COLA架构总览
	- ### 12.6　本章小结
	- ## 第13章工匠平台
	- ### 13.1　项目背景
	- ### 13.2　整理需求
	- ### 13.3　工匠Demo
	- ### 13.4　使用COLA
	- ### 13.4.1　安装COLA
	- ### 13.4.2　搭建应用
	- ### 13.5　领域模型
	- ### 13.5.1　领域建模
	- ### 13.5.2　领域词汇表
	- ### 13.6　核心业务逻辑
	- ### 13.7　实现技术细节
	- ### 13.7.1　数据存储
	- ### 13.7.2　控制器
	- ### 13.8　测试
	- ### 13.8.1　单元测试
	- ### 13.8.2　集成测试
	- ### 13.8.3　回归测试
	- ### 13.9　本章小结
- >%%
  >```annotation-json
  >{"created":"2022-02-03T07:03:36.426Z","text":"命名","updated":"2022-02-03T07:03:36.426Z","document":{"title":"代码精进之路：从码农到工匠（异步图书）（对于很多一直“低头拉车”的程序员来说，这本书能够让你不必\"抬头\"就能看到未来的出路。 ）","link":[{"href":"urn:x-pdf:39363164326233636235633837636634376532323831613563353434383138323937663539326663383962663337646636386435363362326164636662636533"},{"href":"vault:/assets/%E4%BB%A3%E7%A0%81%E7%B2%BE%E8%BF%9B%E4%B9%8B%E8%B7%AF_1641218044952_0.pdf"}],"documentFingerprint":"39363164326233636235633837636634376532323831613563353434383138323937663539326663383962663337646636386435363362326164636662636533"},"uri":"vault:/assets/%E4%BB%A3%E7%A0%81%E7%B2%BE%E8%BF%9B%E4%B9%8B%E8%B7%AF_1641218044952_0.pdf","target":[{"source":"vault:/assets/%E4%BB%A3%E7%A0%81%E7%B2%BE%E8%BF%9B%E4%B9%8B%E8%B7%AF_1641218044952_0.pdf","selector":[{"type":"TextPositionSelector","start":11620,"end":11648},{"type":"TextQuoteSelector","exact":"无论是对于人名，还是企业名、产品名，命名都有着巨大的力量","prefix":"。更多书籍访问精品下载网www.j9p.com1.1 命名的力量","suffix":"。在阿里巴巴初创时期，马云想做一个国际化的电子商务网站，要起一个"}]}]}
  >```
  >%%
  >*%%PREFIX%%。更多书籍访问精品下载网www.j9p.com1.1 命名的力量%%HIGHLIGHT%% ==无论是对于人名，还是企业名、产品名，命名都有着巨大的力量== %%POSTFIX%%。在阿里巴巴初创时期，马云想做一个国际化的电子商务网站，要起一个*
  >%%LINK%%[[#^c0kh1jwdqgu|show annotation]]
  >%%COMMENT%%
  >命名
  >%%TAGS%%
  >
  ^c0kh1jwdqgu
  
  
  >%%
  >```annotation-json
  >{"created":"2022-02-03T07:04:09.860Z","text":"命名","updated":"2022-02-03T07:04:09.860Z","document":{"title":"代码精进之路：从码农到工匠（异步图书）（对于很多一直“低头拉车”的程序员来说，这本书能够让你不必\"抬头\"就能看到未来的出路。 ）","link":[{"href":"urn:x-pdf:39363164326233636235633837636634376532323831613563353434383138323937663539326663383962663337646636386435363362326164636662636533"},{"href":"vault:/assets/%E4%BB%A3%E7%A0%81%E7%B2%BE%E8%BF%9B%E4%B9%8B%E8%B7%AF_1641218044952_0.pdf"}],"documentFingerprint":"39363164326233636235633837636634376532323831613563353434383138323937663539326663383962663337646636386435363362326164636662636533"},"uri":"vault:/assets/%E4%BB%A3%E7%A0%81%E7%B2%BE%E8%BF%9B%E4%B9%8B%E8%B7%AF_1641218044952_0.pdf","target":[{"source":"vault:/assets/%E4%BB%A3%E7%A0%81%E7%B2%BE%E8%BF%9B%E4%B9%8B%E8%B7%AF_1641218044952_0.pdf","selector":[{"type":"TextPositionSelector","start":12696,"end":12717},{"type":"TextQuoteSelector","exact":"在计算机科学中有两件难事：缓存失效和命名。","prefix":"，Martin  Fowler也表示过，他最喜欢的一句谚语是：“","suffix":"（There  are  only  two  hardthin"}]}]}
  >```
  >%%
  >*%%PREFIX%%，Martin  Fowler也表示过，他最喜欢的一句谚语是：“%%HIGHLIGHT%% ==在计算机科学中有两件难事：缓存失效和命名。== %%POSTFIX%%（There  are  only  two  hardthin*
  >%%LINK%%[[#^nemd9aafkvc|show annotation]]
  >%%COMMENT%%
  >命名
  >%%TAGS%%
  >
  ^nemd9aafkvc
  
  
  >%%
  >```annotation-json
  >{"created":"2022-02-03T07:05:04.684Z","text":"业务语义","updated":"2022-02-03T07:05:04.684Z","document":{"title":"代码精进之路：从码农到工匠（异步图书）（对于很多一直“低头拉车”的程序员来说，这本书能够让你不必\"抬头\"就能看到未来的出路。 ）","link":[{"href":"urn:x-pdf:39363164326233636235633837636634376532323831613563353434383138323937663539326663383962663337646636386435363362326164636662636533"},{"href":"vault:/assets/%E4%BB%A3%E7%A0%81%E7%B2%BE%E8%BF%9B%E4%B9%8B%E8%B7%AF_1641218044952_0.pdf"}],"documentFingerprint":"39363164326233636235633837636634376532323831613563353434383138323937663539326663383962663337646636386435363362326164636662636533"},"uri":"vault:/assets/%E4%BB%A3%E7%A0%81%E7%B2%BE%E8%BF%9B%E4%B9%8B%E8%B7%AF_1641218044952_0.pdf","target":[{"source":"vault:/assets/%E4%BB%A3%E7%A0%81%E7%B2%BE%E8%BF%9B%E4%B9%8B%E8%B7%AF_1641218044952_0.pdf","selector":[{"type":"TextPositionSelector","start":13808,"end":13850},{"type":"TextQuoteSelector","exact":"实体类承载了核心业务数据和核心业务逻辑，其命名要充分体现业务语义，并在团队内达成共识","prefix":"封装。对于一个应用系统，我们可以将类分为两大类：实体类和辅助类。","suffix":"，如Customer、Bank和Employee等。辅助类是辅佐"}]}]}
  >```
  >%%
  >*%%PREFIX%%封装。对于一个应用系统，我们可以将类分为两大类：实体类和辅助类。%%HIGHLIGHT%% ==实体类承载了核心业务数据和核心业务逻辑，其命名要充分体现业务语义，并在团队内达成共识== %%POSTFIX%%，如Customer、Bank和Employee等。辅助类是辅佐*
  >%%LINK%%[[#^6j6bc2xsju|show annotation]]
  >%%COMMENT%%
  >业务语义
  >%%TAGS%%
  >
  ^6j6bc2xsju